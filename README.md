# Self-Hosted Password Vault with Remote Access

Here's how I'm going to create a self hosted password vault with remote access (any external storage device for me I'll be using an external hard disk).

## Goals

1. To create a password vault on my hard disk
2. I have a dedicated password manager folder "passmanager" on the external hard disk
3. To encrypt the passwords and not have them in plain text
4. To have authentication before viewing / adding passwords
5. To have remote secure access from my phone when the following conditions are met:
   - a) external hard disk is connected to my computer
   - b) computer is online
6. Create a one way secure channel from my phone to pull data from my computer using a GUI

Well that's the base of it.

## The Plan

### 1. Secure Storage on the External Drive

a) I'll create a folder "passmanager"
b) The passwords will be stored in a simple encrypted json file
c) Also I will use symmetric encryption AES 256 with a master password/key

> **FYI:** If you are reading this never store the master key on the same disk. But again if you are reading this my scripts do not allow that.
> Personally, I'll be using python + cryptography library.

### 2. Authentication

Master password will be required locally. The API token generated by the server.py is what will be required on your phone's browser (also if you are reading this and have a way that the API can be just cached instead of entering it manually to view your records please help).

You can also add a 2FA/TOTP layer (time based one time password layer) what this essentially does is, it generates temporary numeric codes like those in an authenticator for a short period of time (it basically hardens security).

### 3. Remote Access

Since my disk will be plugged into my computer, I will do the following to ensure remote access from my phone:

a) Run a lightweight server I'll be using FastAPI that exposes endpoints to fetch passwords.
   - Then the server reads from the encrypted database only after correct authentication that's the master password.
   - Passwords are sent only after decryption in memory

b) I will encrypt traffic end to end, well I won't encrypt it, I will be using tailscale so basically all traffic between my phone and my PC goes through WireGuard tunnels established by Tailscale.
   And WireGuard provides end-to-end encryption (E2E) using modern crypto. So yeah tailscale will do it for me. Is it like crackable? I don't know basically. It seems secure to me. Options are not limited.

Now for a bit more security:
- I will only expose the server to me and not the public internet which is why I ended up on tailscale as it will enable secure tunneling into my home machine from my phone. (one way comms)

### 4. Remote Connection Setup

We have multiple options for the remote connection as I had indicated earlier. I'll list some of them if you are adventurous enough feel free to test them out.

a) Tailscale secure access to your home network
b) Reverse SSH tunnel (do this if your computer is behind NAT)
c) Self hosted HTTPS with port forwarding (personally I do not recommend this as it's the least secure option) but nevertheless you can try it you may learn a couple of things about port forwarding

## Building the Solution

Now that was the blueprint, let's build the actual house (I'll try to build one that won't be blown down by some wolf ðŸ˜‚)

> *I used python 3.12.1 as my interpreter on VS Code*

### Part A: CLI Vault Script

First I'll write the script, a practical CLI vault that can be run locally to store an AES-GCM encrypted JSON vault inside /Passmanager:

- It keeps the master password only in memory and uses a strong KDF (Key Derivation Function) which is basically a cryptographic algorithm used to generate strong secret keys from some initial input (like a password or shared secret)
- In detail I will use (PBKDF2-HMAC-SHA256) what this means is:
  - **PBKDF2** = password based key derivation function 2. It takes a password + salt + iteration count and produces a derived key.
  - **HMAC** = hash based message authentication code. This just read about basic hashing. It just ensures cryptographic strength.
  - **SHA256** = this is a secure hash algorithm 256 bit (32 bytes).

#### Example:
We have:
- password "my password"
- salt "ice_spice"
- iterations 100,000
- output length 32 bytes

This will apply HMACSHA256 (password,salt) repeatedly for 100,000 iterations. Combines the output to stretch the entropy. The output is a 256 bit derived key usable for AES,TLS.

**What's the purpose of all this John?** you may wonder or ask. Well:
1. It slows down attackers
2. It resists rainbow tables

### Part B: Dependencies

Make sure you install the following dependency:
pip install cryptography

Then the code for this particular vault is in skid_vault.py
- The vault will stay encrypted on disk only decrypted in memory when the master password is entered

## Testing skid_vault.py Locally

### Step 1: Initialize the Vault

I created a subfolder lock inside the main folder Passmanager such that skid_vault.py and lock are in the same directory.

Passmanager/
â”‚
â”œâ”€â”€ skid_vault.py        # Your main Python script
â”‚
â””â”€â”€ lock/

Run this:
python skid_vault.py init

This will check if the folder lock exists then saves the file vault.bin in the folder

### Step 2: CRUD Operations

I will be showing how to perform the CRUD (create, read, update, delete) operations on an entry (example entry of course) on CLI

#### THE BELOW SHOWS CRUD SCRIPTS FOR THE PASSWORD MANAGER

**THIS CREATES AN ENTRY:**
python skid_vault.py add --name gmail --user you@gmail.com --secret "p@ssw0rd123" --notes "Main email"

**THIS SHOWS A PARTICULAR ENTRY (READ):**
python skid_vault.py list
python skid_vault.py get --name gmail

**TO UPDATE A PARTICULAR ENTRY:**
# update just the secret
python skid_vault.py update --name gmail --secret "newStrongPass!"

# update both user and notes
python skid_vault.py update --name gmail --user "newmail@gmail.com" --notes "2FA enabled"

**THIS DELETES A PARTICULAR ENTRY:**
python skid_vault.py delete --name gmail

**THIS BACKS-UP THE ENCRYPTED FILE:**
python skid_vault.py backup --out ~/vault-backup.enc

**THIS RESTORES THE BACK-UP:**

New Restore Command Usage

Backup vault:
python skid_vault.py backup --out D:\backup_vault.bin

Restore vault:
python skid_vault.py restore --src D:\backup_vault.bin

**THIS IS HOW TO CHANGE THE MASTER PASSWORD:**
python skid_vault.py change-master

### More features to come up as time goes by

## Remote Access Layer

For now let's move on, next I'll be wiring up a secure remote access layer.
- I will be using tailscale + FastAPI for the architecture
- A FastAPI server will:
  a) authenticate with a bearer token
  b) enforce basic rate limiting
  c) keep an audit log
  d) decrypt the AES-GCM vault in memory per request
  e) serve only minimal endpoints requested

Let's get to it then.

### 1. Architecture and Security

a) I've been repetitive on this it's starting to seem a bit awkward. But anyway, for the network tunnel I will use tailscale which is a WireGuard based mesh VPN.
   - This will provide device to device connectivity without opening firewall ports. You'll have to install it both on PC and phone I'll explain it later.

b) For the transport security, tailscale already provides E2E encryption. You can add HTTPS if you expose the server outside tailscale.

c) For auth bearer token that only you store on your phone app. The token is checked on every request. (this is what I was asking for help on)

d) Vault decryption: the vault is decrypted only in memory for each request using the master password you supply when starting the server (it's never stored on disk)

e) Audit: append-only JSONL file audit.log in lock with a timestamp, masked token id, action, entry name, client ip, and success/failure.

### 2. Dependencies

Run this on the machine where the disk is plugged in:
python -m pip install fastapi uvicorn cryptography

### 3. Scaffold the Server

The file for the server is skid_server.py

### 4. Running the Server Locally

- Make sure the vault file exists first
- Put the skid_server.py in the same working directory
- Install dependencies in step 2
- Start the server by typing this on the terminal:
  python skid_server.py --host 127.0.0.1 --port 8080
  
  This is just to test the server
  
  *This creates a file server_token.txt in lock*

### 5. Connect from Your Phone Using Tailscale

a) Install tailscale on your PC and phone and log in by using the same account on both devices

b) Note your PC tailscale IP

c) On your phone make a request to http://<pc tailscale ip>:8080 from the browser

**FYI:** DO THIS AFTER STARTING THE SERVER AGAIN LIKE THIS:
python skid_server.py --host <pc tailscale ip> --port 8080

- I implemented a front end on the server file which will show up on your browser.
- You can perform all CRUD operations from this frontend if you don't prefer CLI.

## Conclusion

Basically that's it you now have your own self hosted password vault that only you can access and self customizable to your liking. Feel free to point out any issues and better options.